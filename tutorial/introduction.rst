.. _tut-informal:

***********************************
Пайтон хэлний танилцуулга
***********************************

Доорх жишээнүүдэд програмийн оролт гаралт нь мөрийн эхлэлийн тэмдэгтүүдээрээ
ялгарна (``>>>`` ба ``...``): Жишээн дээрхийг туршиж үзэхийн тулд эдгээр тэмдэгтүүдээр
эхэлж байгаа текстийг дууриаж бичих ба эдгээр тэмдэгтүүдээр эхлээгүй байвал
энэ нь программийн гаралт юм. Гурван цэгээр эхэлж байгаа нь олон мөртэй
код бичихэд гарч ирдэг. Харин гурван багын тэмдгээр эхэлж байвал тэнд код бичиж
болно таныг бичихийг хүлээж байна.

Пайтон кодны тайлбар нь ``#`` чагт тэмдгээр эхэлж мөрний төгсгөл хүртэлх нь
тайлбар болдог. Гарын авлагын маш олон жишээнүүд, тэр дундаа харилцуур цонхтой ажилласан
жишээнүүд дээр хүртэл тайлбар хийж тэмдэглэсэн. Чагт тэмдгээс урагш тэмдэгтүүд нь
тайлбар болохгүй ба код байвал ажиллана. Харин тэмдэгт мөрийн зарлагаан доторх
чагт нь тайлбар болохгүй.

Жишээ нь::

   # Энэ эхний тайлбар
   SPAM = 1                 # харин энэ хоёр дах нь
                            # ... гуравдах 
   STRING = "# Энэ тайлбар биш, тэмдэгт мөрийн зарлагаа."


.. _tut-calculator:

Тооны машины зориулалтаар ашиглах
=================================

Харилцуур цонхоо эхлүүл, ``>>>`` тэмдэгтээр эхлэх мөр гарч иртэл хүлээсний дараа 
код бичнэ.


.. _tut-numbers:

Тоо
---

Харилцуур нь энгийн тооны машин шиг ажилладаг, бичсэн илэрхийллийг дор нь
боловсруулаад гаргадаг. Илэрхийллийн синтакс нь энгийн, бусад ихэнх програмчлалын
хэлтэй адилхан ``+``, ``-``, ``*``, ``/`` операторууд нь харгалзан нэмэх, хасах,
үржих, хуваах үйлдэл. Хаалтыг математик илэрхийллээ бүлэглэх үед ашиглана.

   >>> 2+2
   4
   >>> # Энд тайлбар
   ... 2+2
   4
   >>> 2+2  # Эх кодны араас үргэлжлүүлэн тайлбар
   4
   >>> (50-5*6)/4
   5
   >>> # Бүхэл тоон хуваалт нь бүхэл тоог буцаана:
   ... 7/3
   2
   >>> 7/-3
   -3

``'='`` гэсэн тэнцүүгийн тэмдгийг хувьсагчид утга олгох үед хэрэглэнэ. Утга
олголтын дараагийн мөрөнд юу ч хэвлэгдэхгүй.

   >>> width = 20
   >>> height = 5*9
   >>> width * height
   900

Утга олгох үйлдэл нь зэрэг хийгдэж болно.

   >>> x = y = z = 0  # x, y, z-ийн утга 0
   >>> x
   0
   >>> y
   0
   >>> z
   0

Хувьсагчийг хэрэглэхээсээ өмнө тодорхойлсон байх шаардлагатай. Эс бөгөөс алдаа
гарна::

   >>> # урьд нь ашиглаж байгаагүй хувьсагч руу хандах
   ... n
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   NameError: name 'n' is not defined

Бутархай тоог илэрхийлэлд ашиглах үед бүхэл тоон төрлийн утгууд нь бутархай болж
хувирснаар үр дүн нь бутархай байна::

   >>> 3 * 3.75 / 1.5
   7.5
   >>> 7.0 / 2
   3.5

Мөн комплекс тоо ашиглаж болно. Хуурмаг тооны ард ``j``, ``J`` тэмдэгтийг тавина.
Бодит хэсэг нь тэгээс ялгаатай бол ``(real+imagj)`` гэх маягаар, эсвэл ``complex(real, imag)``
гэсэн функцийн дуудалтаар байгуулна. ::

   >>> 1j * 1J
   (-1+0j)
   >>> 1j * complex(0,1)
   (-1+0j)
   >>> 3+1j*3
   (3+3j)
   >>> (3+1j)*3
   (9+3j)
   >>> (1+2j)/(1+1j)
   (1.5+0.5j)

Комплекс тоо нь бодит болон хуурмаг хэсэгтэй. Эдгээр 2 хэсэг рүү хандахын тулд
``z.real``-ийг бодит хэсэг рүү нь хандахын тулд, ``z.imag``-ээр хуурмаг хэсгийн
утгыг авна. ::

   >>> a=1.5+0.5j
   >>> a.real
   1.5
   >>> a.imag
   0.5

Бутархай, бүхэл тоон төрөл болгон хувиргах функцүүд (:func:`float`,
:func:`int` and :func:`long`) нь комплекс тоон дээр үйлчлэхгүй.

   >>> a=3.0+4.0j
   >>> float(a)
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   TypeError: can't convert complex to float; use abs(z)
   >>> a.real
   3.0
   >>> a.imag
   4.0
   >>> abs(a)  # sqrt(a.real**2 + a.imag**2)
   5.0

Харилцуур цонхтой ажиллаж байх үед хамгийн сүүлд дэлгэц рүү хэвлэсэн утга нь
``_`` нэртэй хувьсагчид хадгалагддаг. Ингэснээр тооны машин шиг ашиглаж байгаа үед
илэрхийллийг үргэлжлүүлэхэд хялбархан болгодог. Жишээ нь ::

   >>> tax = 12.5 / 100
   >>> price = 100.50
   >>> price * tax
   12.5625
   >>> price + _
   113.0625
   >>> round(_, 2)
   113.06

Энэ хувьсагчийг зөвхөн хандах эрхээр хэрэглэх ёстой. Хэрвээ ямар нэгэн утга олговол
ижил нэртэй локал хувьсагч үүсч энэ хувьсагч руу хандах боломжгүй болно.


.. _tut-strings:

Тэмдэгт мөр
-----------

Тооноос гадна Пайтон нь тэмдэгт мөртэй хэд хэдэн аргаар ажиллаж чадна. Дан болон
давхар дуслууд ашиглан тэмдэгт мөрийг бичнэ. ::

   >>> 'spam eggs'
   'spam eggs'
   >>> 'doesn\'t'
   "doesn't"
   >>> "doesn't"
   "doesn't"
   >>> '"Yes," he said.'
   '"Yes," he said.'
   >>> "\"Yes,\" he said."
   '"Yes," he said.'
   >>> '"Isn\'t," she said.'
   '"Isn\'t," she said.'

Тэмдэгт мөрийг тодорхойлохдоо олон мөртэй болгож бичиж болно. Олон мөрөнд хуваан
хуваан бичихдээ мөрийн төгсгөлд нь буруу налсан зураас тавьснаар зарлагааг дундуур
нь тасалж шинэ мөрөнд үргэлжлүүлэн бичнэ::

   hello = "This is a rather long string containing\n\
   several lines of text just as you would do in C.\n\
       Note that whitespace at the beginning of the line is\
    significant."

   print hello

Тэмдэгт мөрийг зарлаж ашиглах үедээ ``\n`` тэмдэгтийг ашиглан шинэ мөр үүсгэнэ.
Буруу налсан зураасийг олон мөрт салгаж хэрэглэнэ. Тиймээс дээрх жишээ нь дараах
гаралтыг үзүүлнэ:

.. code-block:: text

   This is a rather long string containing
   several lines of text just as you would do in C.
       Note that whitespace at the beginning of the line is significant.

Эсвэл тэмдэгт мөрийг дараалсан гурван дан ``'''`` эсвэл давхар ``"""`` хашилтаар 
хааж тэмдэглэнэ. Мөрийн төгсгөлд буруу налсан зураасыг ашиглах шаардлагагүй.
::
   print """
   Usage: thingy [OPTIONS]
        -h                        Display this usage message
        -H hostname               Hostname to connect to
   """

гаралт нь:

.. code-block:: text

   Usage: thingy [OPTIONS]
        -h                        Display this usage message
        -H hostname               Hostname to connect to

Хэрвээ түүхий тэмдэгт мөрийг зарлаж байгаа бол шинэ мөрний тэмдэгт ``\n``, мөрийн
төгсгөлд олон мөр болгохоор бичсэн буруу налсан зураас нь ямар нэгэн утга илэрхийлэхгүй
тэмдэгт мөрөнд шууд орно. Жишээ нь::

   hello = r"This is a rather long string containing\n\
   several lines of text much as you would do in C."

   print hello

гаралт нь:

.. code-block:: text

   This is a rather long string containing\n\
   several lines of text much as you would do in C.

Харилцуур нь тэмдэгт мөр дээрх үйлдлүүдийн үр дүнг яаж бичсэн яг тэр загвараар
нь буцааж дэлгэцэн дээр гаргадаг. Буруу налсан тэмдэг ашигласан хөгжилтэй тэмдэгтүүд
хүртэл байгаагаараа гардаг. Хэрвээ тэмдэгт мөр нь дан хашилт хэрэглэсэн бол
давхар хашилтаар хааж, харин давхар хашилт хэрэглсэн дан хашилтаар хааж бичих
нь зүйтэй. Хойхно дурдах :keyword:`print` функц нь буруу налсан тэмдэгтүүдийг зөв дүрслэлд
нь оруулж хэвлэдэг.

Тэмдэгт мөрүүдийг ``+`` оператор ашиглан холбож, ``*`` оператороор давтан
үзүүлдэг::

   >>> word = 'Help' + 'A'
   >>> word
   'HelpA'
   >>> '<' + word*5 + '>'
   '<HelpAHelpAHelpAHelpAHelpA>'

2 тэмдэгт мөрийг зэрэгцүүлэн зарлавал автоматаар холбогдоно; Дээрх жишээний
эхний мөрөн дэхийг ``word = 'Help' 'A'`` гэж бичиж болно; Зөвхөн хоёр тэмдэгт
мөрийн хувьд ийм арга хэрэглэж болно, дурын тохиолдолд хэрэглэж болохгүй::

   >>> 'str' 'ing'                   #  <-  Энэ болно
   'string'
   >>> 'str'.strip() + 'ing'   #  <-  Энэ болно
   'string'
   >>> 'str'.strip() 'ing'     #  <-  Алдаатай
     File "<stdin>", line 1, in ?
       'str'.strip() 'ing'
                         ^
   SyntaxError: invalid syntax

Тэмдэгт мөрийг Си програмчлалын хэлтэй адилхнаар индекслэдэг. Тэмдэгт мөрийн хамгийн эхний тэмдэгт
нь 0 дугаартай. Пайтон хэлэнд тэмдэгт гэсэн төрөл байхгүй 1 тэмдэгтийг 1 урттай
тэмдэгт мөр гэж ойлгодог. Мөн тэмдэгт мөрөөс хэсэглэж авах аргатай. ::

   >>> word[4]
   'A'
   >>> word[0:2]
   'He'
   >>> word[2:4]
   'lp'

Хэсэглэж авах аргыг ашиглах үед хоёр захын хязгаарыг зааж байгаа тоо нь анхны
утгатай байдаг тул зааж өгөхгүй байж болно. Эхлэлийн анхны утга нь 0, төгсгөлийн
анхдагч утга нь тэмдэгт мөрийн урт. ::

   >>> word[:2]    # Эхний 2 тэмдэгт
   'He'
   >>> word[2:]    # Эхний 2 тэмдэгтээс хойшхи
   'lpA'

Си хэлний тэмдэгт мөрөөс ялгарах онцлог нь тэмдэгт мөрний дурын тэмдэгтийг
индексээр дамжуулан өөрчилж болохгүй. Хэрвээ хүчээр өөрчилбөл алдаа өгнө::

   >>> word[0] = 'x'
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   TypeError: object does not support item assignment
   >>> word[:1] = 'Splat'
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   TypeError: object does not support slice assignment

Дээрх аргын оронд шинэ тэмдэгт мөрийг холбож үүсгэх нь хялбархан, үр дүнтэй юм::

   >>> 'x' + word[1:]
   'xelpA'
   >>> 'Splat' + word[4]
   'SplatA'

Хэсэглэх үйлдлийн хувьд ``s[:i] + s[i:]`` нийлбэр нь анхны тэмдэгт мөр ``s``-тэй тэнцүү. ::

   >>> word[:2] + word[2:]
   'HelpA'
   >>> word[:3] + word[3:]
   'HelpA'

Тэмдэгт мөрийн уртаас хэтэрсэн индекс нь тэмдэгт мөрийн хэмжээгээр, харин доод хязгаар
нь дээд хязгаараасаа их байвал хоосон тэмдэгт мөр буцаана. ::

   >>> word[1:100]
   'elpA'
   >>> word[10:]
   ''
   >>> word[2:1]
   ''

Индекс нь сөрөг тоо байж болно, тийм үед тэмдэгт мөрийн төгсгөлөөс зүүн тийш тоолно ::

   >>> word[-1]     # The last character
   'A'
   >>> word[-2]     # The last-but-one character
   'p'
   >>> word[-2:]    # The last two characters
   'pA'
   >>> word[:-2]    # Everything except the last two characters
   'Hel'

Сөрөг тэг нь тэгтэй адилхан учраас баруун талаас тоолохгүй!
::

   >>> word[-0]     # (since -0 equals 0)
   'H'

Тэмдэгт мөрийн уртаас хэтэрсэн сөрөг индексийг хэсэглэх үед ашиглахад асуудал
үүсэхгүй. Гэхдээ үүнийг тэмдэгт рүү шууд хандах үед болгоомжтой хэрэглэх хэрэгтэй::

   >>> word[-100:]
   'HelpA'
   >>> word[-10]    # error
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   IndexError: string index out of range

Хэрхэн хэсэглэж байгааг ойлгохын тулд тэмдэгт бүрийн 2 талд индекс байгаа гэж
ойлгоно. Зүүнээс баруун тийш өсөх дарааллаар хамгийн эхний тэмдэгтийн зүүн
талд 0 харин баруун талд нь 1. Тиймээс дараагийн буюу 2-дах тэмдэгтийн зүүн
талд нь 1 баруун талд нь 2 гэх мэтчилэн үргэлжилнэ. ::

    +---+---+---+---+---+
    | H | e | l | p | A |
    +---+---+---+---+---+
    0   1   2   3   4   5
   -5  -4  -3  -2  -1

Жишээн дэх 2 мөр тоонуудын эхний мөрнийх нь эерэг дугаарлалтыг харин дараагийн
мөр нь сөрөг дугаарлалтыг үзүүлж байна. *i*-ээс *j* хүртэлх тэмдэгтүүд нь *i* гэж тэмдэглэгдсэн
ирмэгээс *j* гэж тэмдэглэгдсэн ирмэг хүртэлх тэмдэгтүүдийг оруулна.

Дотоод функц :func:`len` нь тэмдэгт мөрийн уртыг буцаана::

   >>> s = 'supercalifragilisticexpialidocious'
   >>> len(s)
   34


.. Нэмэлт материал::

   :ref:`typesseq`
      Тэмдэгт мөр, Юникод тэмдэгт мөрийг дараагийн хэсэгт үзүүлэх болно, эдгээр
      нь *дараалан хандах* төрлийн нэгэн жишээ бөгөөд, тэдгээр дээр хийгдэх
      зарим үйлдлүүдийг дэмждэг.

   :ref:`string-methods`
      Тэмдэгт мөр болон, Юникод тэмдэгт мөрүүд нь үндсэн үйлдлүүдийг хийх
      олон тооны функцүүдтэй.

   :ref:`new-string-formatting`
      Доор тэмдэгт мөрийг загварчлах :meth:`str.format` функцийн талаар тодруулах
      болно.

   :ref:`string-formatting`
      Мөн эдгээр тэмдэгт мөрүүдийг загварчлах ``%`` операторын талаар доор дэлгэрэнгүй 
      дурдана.


.. _tut-unicodestrings:

Юникод тэмдэгт мөр
------------------

.. sectionauthor:: Marc-Andre Lemburg <mal@lemburg.com>


Пайтон 2.0 хувилбараас эхлэн текстийн шинэ төрөл гарч ирсэн нь Юникод объект юм.
Юникод объектийг(http://www.unicode.org/ үзнэ үү) хадгалах болон боловсруулахад ашигладаг.
Мөн өмнө тэмдэгт мөртэй хамтран ажиллах боломжоор хангаж зарим тохиолдолд автоматаар 
тэмдэгт мөр Юникод тэмдэгт мөрийн хооронд хувиргалт хийдэг.

Юникод нь орчин үеийн болон дээр үеийн бүхий л текстүүдийн тэмдэгт бүрт давтагдашгүй
тоо өгч хадгалдгаараа давуу талтай. Өмнө нь зөвхөн 256 тэмдэгтийг л хадгалдаг 
байсан. Өөр тэмдэгт ашиглах болсон тохиолдолд дугаарыг нь тэмдэгт рүү буулгасан
нэмэлт кодчлолын хүснэгтийг хавсаргадаг. Юникод нь бүх тэмдэгтүүдэд зориулсан
ганцхан кодчлолын хүснэгтийг бий болгосон юм.

Юникод тэмдэгт мөрийг Пайтонд үүсгэх нь энгийн тэмдэгт мөрийг үүсгэж
байгаа бараг адилхан::

   >>> u'Hello World !'
   u'Hello World !'

Тэмдэгт мөрийн эхэнд байрлах ``'u'`` тэмдэг нь Юникод тэмдэгт мөрийг зохиож
байгааг илтгэнэ. Хэрвээ тусгай Юникод тэмдэгтийг оруулахаар бол *Юникод-Тэмдэглэгээ* 
аргыг ашиглана. Жишээн дээр хэрхэн хийхийг үзүүлэв::

   >>> u'Hello\u0020World !'
   u'Hello World !'

``\u0020`` гэсэн Юникод тэмдэглэгээ нь 0x0020 дугаартай тэмдэгт буюу хоосон
зайг тухайн байрлалд оруулжээ.

Юникод тэмдэглэгээ ашиглаагүй бусад тэмдэгтүүд нь шууд Юникодын дугаараа авна.
Учир нь Латин-1 кодчлолын 256 тэмдэгт нь Юникодын бага 256 тэмдэгттэй адил байдаг.

Тэмдэгт мөрийг түүхий байдлаар нь тэмдэглэхэд ашигладаг *r* гэсэн утгварын хажууд
*u* -г нэмж өгөөд *Түүхий-Юникод-Тэмдэглэгээг* ашиглаж болно. Энэ үед зөвхөн
``\uXXXX`` тэмдэгтүүдийг л хөрвүүлдэг. Бусад буруу налсан зураас нь ямар нэгэн утга
агуулахгүй. ::

   >>> ur'Hello\u0020World !'
   u'Hello World !'
   >>> ur'Hello\\u0020World !'
   u'Hello\\\\u0020World !'

Тэмдэгт мөрийг түүхийгээр нь тэмдэглэх нь текстийн хэв болон олон тооны буруу 
налсан зураастай тэмдэгт мөртэй ажиллах үед ойлгомжтой болгодог.

Эдгээр стандард кодчлолуудаас гадна Пайтон өргөн хэрэглэгддэг кодчлолуудтай ажиллах
функцийг бэлтгэж өгсөн. 

.. index:: builtin: unicode

:func:`unicode` дотоод функц нь бүх Юникод кодчлогч болон тайлах кодчлолд хандахад
хэрэглэгдэнэ. Зарим нэр бүхий кодчлолуудыг дурдвал *Latin-1*, *ASCII*, *UTF-8*, *UTF-16*.
Энд сүүлийн 2 нь хувьсах урттай ба тэмдэгтүүдийг 1 болон түүнээс дээшхи байтад хадгалдаг.
Анхдагч кодчлолын утга нь ASCII юм. Энэ нь 0-127 хүртэлх тоогоор тэмдэгтүүдийг дугаарладаг. 
127-оос дээш дугаартай тэмдэгттэй тааралдах үед алдаа гаргадаг. Юникод тэмдэгт мөрийг хэвлэх
файл руу бичих :func:`str` функц ашиглаж хувиргах үед анхдагч кодчлол руу хувиргадаг. ::

   >>> u"abc"
   u'abc'
   >>> str(u"abc")
   'abc'
   >>> u"äöü"
   u'\xe4\xf6\xfc'
   >>> str(u"äöü")
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)

Юникод тэмдэгт мөрийг тодорхой кодчлол руу хувиргахдаа :func:`encode` функцийг
ашигладаг. Аргументаар кодчлолынхоо нэрийг жижиг тэмдэгт ашиглан бичнэ. ::

   >>> u"äöü".encode('utf-8')
   '\xc3\xa4\xc3\xb6\xc3\xbc'

Өгөгдөл чинь тусгай кодчлол ашигласан үед нь :func:`unicode` функцийн тусламжтайгаар
Юникод руу хөрвүүлнэ. Хоёр дах аргументаар нь кодчлолын нэрийг өгнө. ::

   >>> unicode('\xc3\xa4\xc3\xb6\xc3\xbc', 'utf-8')
   u'\xe4\xf6\xfc'


.. _tut-lists:

Жагсаалт
--------

Пайтон нь өөр өөр утгуудыг нийлүүлж бүлэглэхэд хэрэглэдэг хэд хэдэн *нийлмэл* өгөгдлийн 
төрөлтэй. Хамгийн өргөн хэрэглэгддэг нь *жагсаалт* төрөл юм. Жагсаалтыг
дөрвөлжин хаалтанд таслалаар тусгаарлан бичнэ. Жагсаалтын элементүүд нь бүгд ижил
төрлийн байх албагүй. ::

   >>> a = ['spam', 'eggs', 100, 1234]
   >>> a
   ['spam', 'eggs', 100, 1234]

Тэмдэгт мөртэй адилаар жагсаалт нь 0-ээс эхэлж, хэсэглэж, холбож зэрэг үйлдлүүдийг
дэмжинэ ::

   >>> a[0]
   'spam'
   >>> a[3]
   1234
   >>> a[-2]
   100
   >>> a[1:-1]
   ['eggs', 100]
   >>> a[:2] + ['bacon', 2*2]
   ['spam', 'eggs', 'bacon', 4]
   >>> 3*a[:3] + ['Boo!']
   ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']

Хэсэглэх үйлдэл нь шинэ жагсаалтыг сонирхсон элементүүдтэй нь буцаана. 
Шинэ жагсаалт нь өмнөх жагсаалтынхаа хуулбар нь байна. Ижилхэн биш! ::

   >>> a[:]
   ['spam', 'eggs', 100, 1234]

Тэмдэгт мөр нь өөрчлөх боломжгүй байдаг бол жагсаалтын хувьд дурын элементэд
утга олгож болдог::

   >>> a
   ['spam', 'eggs', 100, 1234]
   >>> a[2] = a[2] + 23
   >>> a
   ['spam', 'eggs', 123, 1234]

Хэсэглэсэн хэсэгтээ утга олгох бас боломжтой. Энэ нь жагсаалтын хэмжээг өөрчилж
эсвэл бүр бүхлээр нь цэвэрлэнэ::

   >>> # Зарим элементүүдийг шинээр олгоё:
   ... a[0:2] = [1, 12]
   >>> a
   [1, 12, 123, 1234]
   >>> # Заримыг нь устгая:
   ... a[0:2] = []
   >>> a
   [123, 1234]
   >>> # Оруулах:
   ... a[1:1] = ['bletch', 'xyzzy']
   >>> a
   [123, 'bletch', 'xyzzy', 1234]
   >>> # Жагсаалтын эхэнд өөрийг нь хуулбарлаж оруулна
   >>> a[:0] = a
   >>> a
   [123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
   >>> # Жагсаалтыг цэвэрлэх: Ө.Х бүх элементийг нь хоосон жагсаалтаар солих
   >>> a[:] = []
   >>> a
   []

Мөн дотоод :func:`len` функц маань жагсаалтанд ашиглагддаг::

   >>> a = ['a', 'b', 'c', 'd']
   >>> len(a)
   4

Жагсаалтын элемент нь жагсаалт байж болно. Өөрөөр хэлбэл нэг нь нөгөөгөө
агуулсан давхар жагсаалт::

   >>> q = [2, 3]
   >>> p = [1, q, 4]
   >>> len(p)
   3
   >>> p[1]
   [2, 3]
   >>> p[1][0]
   2
   >>> p[1].append('xtra')     # See section 5.1
   >>> p
   [1, [2, 3, 'xtra'], 4]
   >>> q
   [2, 3, 'xtra']

``p[1]`` болон ``q`` хувьсагч нь яг ижилхэн объект заана.


.. _tut-firststeps:

Програмчлах анхны алхмууд
=========================

Пайтонг өмнө үзүүлсэн зөвхөн 2 зүйлийг хооронд нь нэмэх бус түүнээс илүү
комплекс ажилд хэрэглэж болно. Доорх жишээ нь *Фибоначчи*-гийн дэд дарааллыг хэвлэв::

   >>> # Фибоначчийн дараалал:
   ... # дараалсан 2 элементийн дараагийнх нь өмнө 2-ын нийлбэр
   ... a, b = 0, 1
   >>> while b < 10:
   ...     print b
   ...     a, b = b, a+b
   ...
   1
   1
   2
   3
   5
   8

Энэ жишээ нь зарим нэг шинэ онцлогууд үзүүлжээ.

* Эхний мөр нь *зэрэг утга олголт*-ын жишээг ингэж үзүүлжээ. ``a``, ``b`` хувьсагчууд
  нь нэгэн зэрэг 0, 1 гэсэн утгуудыг авна. Сүүлийн мөрөн дээр ч энэ техникийг
  давтав. Эхлээд тэнцүүгийн тэмдгийн баруун талын илэрхийллүүд нь бодогддог.

* :keyword:`while` нь нөхцөл үнэн үед давталтыг үргэлжлүүлсээр байдаг (Энд: ``b < 10``)
  Пайтон нь Си хэлтэй мөн адилаар тэгээс ялгаатай утгыг үнэн, харин тэгийг худал
  гэж авдаг. Мөн хоосон жагсаалт, 0 урттай тэмдэгт мөр, ``None`` объектууд нь
  худал гэгддэг, бусад тохиолдлуудад үнэн байна. Харьцуулах операторууд нь
  Си хэлнийхтэй адилхан: ``<`` бага, ``>`` их, ``==`` тэнцүү, ``<=`` ихгүй, 
  ``>=`` багагүй, ``!=`` ялгаатай гэсэн утгатай.

* Давталтын *эх бие* нь мөрөн дэх эхний хоосон зайгаараа адилхан: Мөр ингэж зэрэгцүүлэх
  нь илэрхийллүүдийг блок илэрхийлэл болгож байгаа юм. Пайтон ухаалгаар мөрөн дэх
  илэрхийллүүдийг боддог учраас мөр болгоны эхлэлд шаардлагатай үед хэдэн хоосон зай
  эсвэл таб зогсолт авах хэрэгтэй. Практик дээр ихэнх текст боловсруулагч програмууд
  нь автоматаар урдаа таб зогсолт авдаг тул тэдгээр тохиргоог боловсруулагчдаа
  хийж өгөх хэрэгтэй. Урдаа хоосон зай аваагүй үед блок илэрхийллийн төгсгөл гэж
  харилцуур цонх ойлгоод ажиллуулж эхлүүлдэг. Нэг блокны илэрхийлэл нь яг ижилхэн
  тооны ижилхэн зай авах тэмдэгтэй байх ёстой.

* 
  :keyword:`print` функцийг ашиглан илэрхийллийн утгыг дэлгэц рүүгээ хэвлэхэд
  хэрэглэнэ. Өмнөх тооны машинтай жишээнээс ялгарах нь өгөгдлийг дэлгэцэнд цэвэрхэн
  үзүүлдэг, мөн хоёр талын хашилт тэмдэгтүүдийг хасаад цэвэрхэн хэвлэдэнэ::

     >>> i = 256*256
     >>> print 'The value of i is', i
     The value of i is 65536

::
     >>> a, b = 0, 1
     >>> while b < 1000:
     ...     print b,
     ...     a, b = b, a+b
     ...
     1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

  Харилцуур цонхны дараагийн мөр хэвлэгдэхийнхээ өмнө дэлгэц рүү шинэ мөр авах
  тэмдэгтийг бичдэг.
